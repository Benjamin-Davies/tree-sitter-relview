==================
Dfs
==================

{************************************************************
 Recursive computation of the DFS-forest of a directed graph
 following the standard approach
************************************************************}

DfsVisit(R,p,v)
  DECL q, u, w, T
  BEG  T = O(R);
       u = v | p;
       w = R^ * p & -u;
       WHILE -empty(w) DO
         q = point(w);
         T = T | p * q^ | DfsVisit(R,q,u);
         u = u | T^ * Ln1(R);
         w = R^ * p & -u
         OD
       RETURN T
  END.

Dfs(R)
  DECL p, v, F
  BEG  F = O(R);
       v = On1(R);
       WHILE -empty(-v) DO
         p = point(-v);
         F = F | DfsVisit(R,p,v);
         v = v | p | F^ * Ln1(R)
         OD
       RETURN F
  END.

---

(source_file
  (comment)
  (definition
    (identifier)
    (parameter_list
      (identifier)
      (identifier)
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier)
        (identifier)
        (identifier))
      (assignment_statement
        (identifier)
        (call
          (base_function)
          (argument_list
            (identifier))))
      (assignment_statement
        (identifier)
        (binary_expression
          (identifier)
          (identifier)))
      (assignment_statement
        (identifier)
        (binary_expression
          (transpose
            (identifier))
          (binary_expression
            (identifier)
            (complement
              (identifier)))))
      (while_loop
        (complement
          (call
            (base_function)
            (argument_list
              (identifier))))
        (while_body
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (identifier))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (binary_expression
                (identifier)
                (binary_expression
                  (transpose
                    (identifier))
                  (call
                    (identifier)
                    (argument_list
                      (identifier)
                      (identifier)
                      (identifier)))))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (binary_expression
                (transpose
                  (identifier))
                (call
                  (base_function)
                  (argument_list
                    (identifier))))))
          (assignment_statement
            (identifier)
            (binary_expression
              (transpose
                (identifier))
              (binary_expression
                (identifier)
                (complement
                  (identifier)))))))
      (return_statement
        (identifier))))
  (definition
    (identifier)
    (parameter_list
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier)
        (identifier))
      (assignment_statement
        (identifier)
        (call
          (base_function)
          (argument_list
            (identifier))))
      (assignment_statement
        (identifier)
        (call
          (base_function)
          (argument_list
            (identifier))))
      (while_loop
        (complement
          (call
            (base_function)
            (argument_list
              (complement
                (identifier)))))
        (while_body
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (complement
                  (identifier)))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (call
                (identifier)
                (argument_list
                  (identifier)
                  (identifier)
                  (identifier)))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (binary_expression
                (identifier)
                (binary_expression
                  (transpose
                    (identifier))
                  (call
                    (base_function)
                    (argument_list
                      (identifier)))))))))
      (return_statement
        (identifier)))))

==================
ChromNumbZ
==================

{************************************************************
 Recursive computation of the chromatic number of an undir-
 ected and loop-free graph using the algorithm of Zykov. For
 details, see Emden-Weinert et al., p. 146. The chromatic
 number is represented by the number of rows of the result-
 ing universal vector
************************************************************}

ContractEdge(E,e)
  DECL M, v
  BEG  v = dom(e);
       M = conc(inj(-v)^,v)
       RETURN ipa(M^ * E * M)
  END.

ChromNumbZ(E)
  DECL a, e, c, c1, c2
  BEG  IF eq(E,-I(E))
         THEN c = Ln1(E)
         ELSE a = atom(-E & -I(E));
              e = a | a^;
              c1 = ChromNumbZ(E | e);
              c2 = ChromNumbZ(ContractEdge(E,e));
              IF cardlt(c1,c2)
                THEN c = Ln1(c1)
                ELSE c = Ln1(c2) FI FI
       RETURN c
  END.

---

(source_file
  (comment)
  (definition
    (identifier)
    (parameter_list
      (identifier)
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier))
      (assignment_statement
        (identifier)
        (call
          (base_function)
          (argument_list
            (identifier))))
      (assignment_statement
        (identifier)
        (call
          (identifier)
          (argument_list
            (transpose
              (call
                (base_function)
                (argument_list
                  (complement
                    (identifier)))))
            (identifier))))
      (return_statement
        (call
          (identifier)
          (argument_list
            (binary_expression
              (transpose
                (identifier))
              (binary_expression
                (identifier)
                (identifier))))))))
  (definition
    (identifier)
    (parameter_list
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier)
        (identifier)
        (identifier)
        (identifier))
      (if_statement
        (call
          (base_function)
          (argument_list
            (identifier)
            (complement
              (call
                (base_function)
                (argument_list
                  (identifier))))))
        (then_clause
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (identifier)))))
        (else_clause
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (binary_expression
                  (complement
                    (identifier))
                  (complement
                    (call
                      (base_function)
                      (argument_list
                        (identifier))))))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (transpose
                (identifier))))
          (assignment_statement
            (identifier)
            (call
              (identifier)
              (argument_list
                (binary_expression
                  (identifier)
                  (identifier)))))
          (assignment_statement
            (identifier)
            (call
              (identifier)
              (argument_list
                (call
                  (identifier)
                  (argument_list
                    (identifier)
                    (identifier))))))
          (if_statement
            (call
              (base_function)
              (argument_list
                (identifier)
                (identifier)))
            (then_clause
              (assignment_statement
                (identifier)
                (call
                  (base_function)
                  (argument_list
                    (identifier)))))
            (else_clause
              (assignment_statement
                (identifier)
                (call
                  (base_function)
                  (argument_list
                    (identifier))))))))
      (return_statement
        (identifier)))))

==================
ChromNumbC
==================

{************************************************************
 Recursive computation of the chromatic number of an undir-
 ected and loop-free graph using the algorithm of Christofi-
 des. For details, see again Emden-Weinert et al., p. 147.
 The result is again represented by the number of rows of an
 universal vector
************************************************************}

KernelList(R)
  DECL Epsi, REpsi, H1, H2, k
  BEG  Epsi = epsi(On1(R));
       REpsi = R * Epsi;
       H1 = Epsi | REpsi;
       H2 = Epsi & REpsi;
       k = -(L1n(R) * (-H1 | H2))^
       RETURN Epsi * inj(k)^
  END.

ChromNumbC(E)
  DECL delete(R,v) = inj(-v) * R * inj(-v)^;
       K, p, c, d
  BEG  IF empty(E)
         THEN c = true
         ELSE IF eq(E,-I(E))
                THEN c = Ln1(E)
                ELSE K = KernelList(E);
                     p = init(L1n(K)^);
                     c = ChromNumbC(delete(E,K*p));
                     WHILE -empty(next(p)) DO
                       p = next(p);
                       d = ChromNumbC(delete(E,K*p));
                       IF cardlt(d,c) THEN c = d FI
                       OD;
                    c = true + c FI FI
       RETURN c
  END.

---

(source_file
  (comment)
  (definition
    (identifier)
    (parameter_list
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier)
        (identifier)
        (identifier)
        (identifier))
      (assignment_statement
        (identifier)
        (call
          (base_function)
          (argument_list
            (call
              (base_function)
              (argument_list
                (identifier))))))
      (assignment_statement
        (identifier)
        (binary_expression
          (identifier)
          (identifier)))
      (assignment_statement
        (identifier)
        (binary_expression
          (identifier)
          (identifier)))
      (assignment_statement
        (identifier)
        (binary_expression
          (identifier)
          (identifier)))
      (assignment_statement
        (identifier)
        (complement
          (transpose
            (parenthesized_expression
              (binary_expression
                (call
                  (base_function)
                  (argument_list
                    (identifier)))
                (parenthesized_expression
                  (binary_expression
                    (complement
                      (identifier))
                    (identifier))))))))
      (return_statement
        (binary_expression
          (identifier)
          (transpose
            (call
              (base_function)
              (argument_list
                (identifier))))))))
  (definition
    (identifier)
    (parameter_list
      (identifier))
    (program_body
      (decl_list
        (definition
          (identifier)
          (parameter_list
            (identifier)
            (identifier))
          (function_body
            (binary_expression
              (call
                (base_function)
                (argument_list
                  (complement
                    (identifier))))
              (binary_expression
                (identifier)
                (transpose
                  (call
                    (base_function)
                    (argument_list
                      (complement
                        (identifier)))))))))
        (identifier)
        (identifier)
        (identifier)
        (identifier))
      (if_statement
        (call
          (base_function)
          (argument_list
            (identifier)))
        (then_clause
          (assignment_statement
            (identifier)
            (base_function)))
        (else_clause
          (if_statement
            (call
              (base_function)
              (argument_list
                (identifier)
                (complement
                  (call
                    (base_function)
                    (argument_list
                      (identifier))))))
            (then_clause
              (assignment_statement
                (identifier)
                (call
                  (base_function)
                  (argument_list
                    (identifier)))))
            (else_clause
              (assignment_statement
                (identifier)
                (call
                  (identifier)
                  (argument_list
                    (identifier))))
              (assignment_statement
                (identifier)
                (call
                  (base_function)
                  (argument_list
                    (transpose
                      (call
                        (base_function)
                        (argument_list
                          (identifier)))))))
              (assignment_statement
                (identifier)
                (call
                  (identifier)
                  (argument_list
                    (call
                      (identifier)
                      (argument_list
                        (identifier)
                        (binary_expression
                          (identifier)
                          (identifier)))))))
              (while_loop
                (complement
                  (call
                    (base_function)
                    (argument_list
                      (call
                        (base_function)
                        (argument_list
                          (identifier))))))
                (while_body
                  (assignment_statement
                    (identifier)
                    (call
                      (base_function)
                      (argument_list
                        (identifier))))
                  (assignment_statement
                    (identifier)
                    (call
                      (identifier)
                      (argument_list
                        (call
                          (identifier)
                          (argument_list
                            (identifier)
                            (binary_expression
                              (identifier)
                              (identifier)))))))
                  (if_statement
                    (call
                      (base_function)
                      (argument_list
                        (identifier)
                        (identifier)))
                    (then_clause
                      (assignment_statement
                        (identifier)
                        (identifier))))))
              (assignment_statement
                (identifier)
                (binary_expression
                  (base_function)
                  (identifier)))))))
      (return_statement
        (identifier)))))

==================
ReflTransCl1
==================

{************************************************************
 Recursive computation of the reflexive-transitive closure
 by deleting a single arc
************************************************************}

ReflTransCl1(R)
  DECL C, A
  BEG  IF empty(R) THEN C = I(R)
                   ELSE A = atom(R);
                        C = ReflTransCl1(R & -A);
                        C = C | C * A * C FI
       RETURN C
  END.

---

(source_file
  (comment)
  (definition
    (identifier)
    (parameter_list
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier))
      (if_statement
        (call
          (base_function)
          (argument_list
            (identifier)))
        (then_clause
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (identifier)))))
        (else_clause
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (identifier))))
          (assignment_statement
            (identifier)
            (call
              (identifier)
              (argument_list
                (binary_expression
                  (identifier)
                  (complement
                    (identifier))))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (binary_expression
                (identifier)
                (binary_expression
                  (identifier)
                  (identifier)))))))
      (return_statement
        (identifier)))))

==================
ReflTransCl2
==================

{************************************************************
 Recursive computation of the reflexive-transitive closure
 by deleting the outgoing arcs of a single vertex
************************************************************}

ReflTransCl2(R)
  DECL C, A, p
  BEG  IF empty(R) THEN C = I(R)
                   ELSE p = point(dom(R));
                        A = p * (p^ * R);
                        C = ReflTransCl2(R & -A);
                        C = C | C * A * C FI
       RETURN C
  END.

---

(source_file
  (comment)
  (definition
    (identifier)
    (parameter_list
      (identifier))
    (program_body
      (decl_list
        (identifier)
        (identifier)
        (identifier))
      (if_statement
        (call
          (base_function)
          (argument_list
            (identifier)))
        (then_clause
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (identifier)))))
        (else_clause
          (assignment_statement
            (identifier)
            (call
              (base_function)
              (argument_list
                (call
                  (base_function)
                  (argument_list
                    (identifier))))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (parenthesized_expression
                (binary_expression
                  (transpose
                    (identifier))
                  (identifier)))))
          (assignment_statement
            (identifier)
            (call
              (identifier)
              (argument_list
                (binary_expression
                  (identifier)
                  (complement
                    (identifier))))))
          (assignment_statement
            (identifier)
            (binary_expression
              (identifier)
              (binary_expression
                (identifier)
                (binary_expression
                  (identifier)
                  (identifier)))))))
      (return_statement
        (identifier)))))
